/*
 * This source file was generated by the Gradle 'init' task
 */
package rivon0507.or.mpm;

import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static rivon0507.or.mpm.MetraPotentialMethod.END_TASK;
import static rivon0507.or.mpm.MetraPotentialMethod.START_TASK;

class MetraPotentialMethodTest {
    static final List<String> TASKS = List.of(
            "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w"
    );
    static final List<Integer> DURATIONS = List.of(
            7, 7, 15, 30, 45, 15, 45, 60, 20, 30, 30, 15, 30, 15, 30, 15, 15, 15, 30, 7, 4, 2, 7
    );
    static final List<List<String>> PREDECESSORS = List.of(
            List.of(),
            List.of("a"),
            List.of("b"),
            List.of("c"),
            List.of("d"),
            List.of("e"),
            List.of("d"),
            List.of("d"),
            List.of("h"),
            List.of("i"),
            List.of("f"),
            List.of("k"),
            List.of("g", "j", "l"),
            List.of("m"),
            List.of("n"),
            List.of("m"),
            List.of("o"),
            List.of("q"),
            List.of("q"),
            List.of("p"),
            List.of("r", "t"),
            List.of("s", "t"),
            List.of("r", "s")
    );

    static final List<String> END_TASKS = List.of("u", "v", "w");
    static final List<String> START_TASKS = List.of("a");

    @Test
    void initializedWithIterablesOfDifferentSizes() {
        assertThrows(
                IllegalArgumentException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c"),
                        List.of(1, 2),
                        List.of(List.of("a", "b", "c"), List.of("d", "e"), List.of("f", "g"))
                ),
                "Iterables of different sizes are not supported"
        );
    }

    @Test
    void initializedWithIterablesOfSameSizes() {
        assertDoesNotThrow(
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c"),
                        List.of(1, 2, 8),
                        List.of(List.of("b", "c"), List.of("c"), List.of())
                ),
                "Initialization should be successful"
        );
    }

    @Test
    void initializedWithSyncedDuplicateInTaskNameAndDurations() {
        assertThrows(
                IllegalArgumentException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c", "c"),
                        List.of(3, 8, 10, 11),
                        List.of(List.of("a", "c"), List.of("b"), List.of(), List.of())
                ),
                "Synced duplicate task name and durations are not supported"
        );
    }

    @Test
    void aTaskHasAPredecessorNotDeclaredInTheTaskNames() {
        assertThrows(
                IllegalArgumentException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c"),
                        List.of(3, 8, 10),
                        List.of(List.of("a", "c"), List.of("b"), List.of("e"))
                )
        );
    }

    @Test
    void initializedWithDuplicateInPredecessors() {
        MetraPotentialMethod method = new MetraPotentialMethod(
                List.of("a", "b", "c"),
                List.of(3, 8, 10),
                List.of(List.of("c"), List.of("a", "a"), List.of())
        );

        assertIterableEquals(
                List.of("a"),
                method.getPredecessors().get("b"),
                "The task b should only have one predecessor : a"
        );
    }

    @Test
    void correctlyInitialized() {
        assertDoesNotThrow(
                () -> new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS),
                "Initialization should be successful"
        );
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);
        int size = TASKS.size();
        for (int i = 0; i < size; i++) {
            String task = TASKS.get(i);
            assertEquals(DURATIONS.get(i), method.getDurations().get(task), "Duration should correspond to task " + task);

            assertTrue(
                    method.getPredecessors().get(task).containsAll(PREDECESSORS.get(i)),
                    "All the predecessors of " + task + " should be present"
            );
            if (PREDECESSORS.get(i).isEmpty()) {
                assertIterableEquals(
                        List.of("start"),
                        method.getPredecessors().get(task),
                        "A task without predecessor should be preceded by start"
                );
            }
        }

        assertIterableEquals(
                Set.copyOf(START_TASKS),
                Set.copyOf(method.getSuccessors().get("start"))
        );

        assertIterableEquals(
                Set.copyOf(END_TASKS),
                Set.copyOf(method.getPredecessors().get("end"))
        );
    }

    @Test
    void noPredecessorListShouldContainDuplicate() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : method.getPredecessors().keySet()) {
            assertEquals(
                    method.getPredecessors().get(task).size(),
                    Set.copyOf(method.getPredecessors().get(task)).size(),
                    "Predecessors of task " + task + " should not contain duplicates"
            );
        }
    }

    @Test
    void noSuccessorListShouldContainDuplicate() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : method.getSuccessors().keySet()) {
            assertEquals(
                    method.getSuccessors().get(task).size(),
                    Set.copyOf(method.getSuccessors().get(task)).size(),
                    "Successors of task " + task + " should not contain duplicates"
            );
        }
    }

    @Test
    void endTaskShouldNotHaveAnySuccessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);
        assertTrue(method.getSuccessors().get(END_TASK).isEmpty(), "Successors of task " + END_TASK + " should be empty");
    }

    @Test
    void startTaskShouldNotHaveAnyPredecessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);
        assertTrue(method.getPredecessors().get(START_TASK).isEmpty(), "Predecessors of task " + START_TASK + " should be empty");
    }

    @Test
    void successorsOfStartShouldOnlyHaveStartAsItsPredecessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : method.getSuccessors().get(START_TASK)) {
            assertIterableEquals(
                    List.of(START_TASK),
                    method.getPredecessors().get(task),
                    "Predecessor of task " + task + "should be only start"
            );
        }
    }

    @Test
    void predecessorsOfEndShouldOnlyHaveEndAsItsSuccessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : method.getPredecessors().get(END_TASK)) {
            assertIterableEquals(
                    List.of(END_TASK),
                    method.getSuccessors().get(task),
                    "Successor of task " + task + "should be only end"
            );
        }
    }

    @Test
    void everyProvidedTaskShouldHaveAtLeastOneSuccessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : TASKS) {
            assertFalse(method.getSuccessors().get(task).isEmpty(), "Task " + task + " should have at least one successor");
        }
    }

    @Test
    void everyProvidedTaskShouldHaveAtLeastOnePredecessor() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        for (String task : TASKS) {
            assertFalse(method.getPredecessors().get(task).isEmpty(), "Task " + task + " should have at least one predecessor");
        }
    }

    @Test
    void shouldReturnCorrectEarliestDates() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);
        Map<String, Integer> earliest = new HashMap<>();
        earliest.put(START_TASK, 0);
        earliest.put("a", 0);
        earliest.put("b", 7);
        earliest.put("c", 14);
        earliest.put("d", 29);
        earliest.put("e", 59);
        earliest.put("f", 104);
        earliest.put("g", 59);
        earliest.put("h", 59);
        earliest.put("i", 119);
        earliest.put("j", 139);
        earliest.put("k", 119);
        earliest.put("l", 149);
        earliest.put("m", 169);
        earliest.put("n", 199);
        earliest.put("o", 214);
        earliest.put("p", 199);
        earliest.put("q", 244);
        earliest.put("r", 259);
        earliest.put("s", 259);
        earliest.put("t", 214);
        earliest.put("u", 274);
        earliest.put("v", 289);
        earliest.put("w", 289);
        earliest.put(END_TASK, 296);

        assertEquals(
                earliest,
                method.earliestDates(),
                "The algorithm should correctly compute the earliest start date for each task"
        );
    }

    @Test
    void shouldReturnCorrectCriticalPath() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);

        List<String> criticalPath = List.of(START_TASK, "a", "b", "c", "d", "h", "i", "j", "m", "n", "o", "q", "s", "w", END_TASK);
        assertIterableEquals(
                criticalPath,
                method.criticalPath(),
                "The algorithm should correctly compute the critical path"
        );
    }

    @Test
    void shouldReturnCorrectLatestDates() {
        MetraPotentialMethod method = new MetraPotentialMethod(TASKS, DURATIONS, PREDECESSORS);
        Map<String, Integer> latest = new HashMap<>();
        latest.put(START_TASK, 0);
        latest.put("a", 0);
        latest.put("b", 7);
        latest.put("c", 14);
        latest.put("d", 29);
        latest.put("e", 64);
        latest.put("f", 109);
        latest.put("g", 124);
        latest.put("h", 59);
        latest.put("i", 119);
        latest.put("j", 139);
        latest.put("k", 124);
        latest.put("l", 154);
        latest.put("m", 169);
        latest.put("n", 199);
        latest.put("o", 214);
        latest.put("p", 270);
        latest.put("q", 244);
        latest.put("r", 274);
        latest.put("s", 259);
        latest.put("t", 285);
        latest.put("u", 292);
        latest.put("v", 294);
        latest.put("w", 289);
        latest.put(END_TASK, 296);

        assertEquals(
                latest,
                method.latestDates(),
                "The algorithm should correctly compute the latest start date for each task"
        );
    }

    @Test
    void whenATaskHasItselfAsItsOwnPredecessor() {
        assertThrows(
                IllegalStateException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c"),
                        List.of(1, 2, 3),
                        List.of(List.of("a"), List.of(), List.of())
                ),
                "Should fail initialization"
        );
    }

    @Test
    void whenATaskHasASymmetricDependencyWithAnother() {
        assertThrows(
                IllegalStateException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c"),
                        List.of(1, 2, 3),
                        List.of(List.of("b"), List.of("a"), List.of())
                )
        );
    }

    @Test
    void whenFourTasksHaveCyclicDependencies() {
        assertThrows(
                IllegalStateException.class,
                () -> new MetraPotentialMethod(
                        List.of("a", "b", "c", "d", "e", "f"),
                        List.of(1, 2, 3, 4, 5, 6),
                        List.of(List.of("b"), List.of("c"), List.of("d"), List.of("a"), List.of("a"), List.of("a"))
                )
        );
    }
}
